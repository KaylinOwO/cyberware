#include "exploits.h"
#include "../../options.hpp"
#include "../../helpers/math.hpp"

void copy_command(CUserCmd* cmd, int tickbase_shift)
{
	static auto cl_forwardspeed = g_CVar->FindVar(XorStr("cl_forwardspeed").c_str());
	static auto cl_sidespeed = g_CVar->FindVar(XorStr("cl_sidespeed").c_str());

	cmd->forwardmove = 0.0f;
	cmd->forwardmove = 0.0f;
	/*else
	{
		if (g_ctx.globals.original_forwardmove >= 5.0f)
			cmd->forwardmove = cl_forwardspeed->GetFloat();
		else if (g_ctx.globals.original_forwardmove <= -5.0f)
			cmd->forwardmove = -cl_forwardspeed->GetFloat();

		if (g_ctx.globals.original_sidemove >= 5.0f)
			cmd->sidemove = cl_sidespeed->GetFloat();
		else if (g_ctx.globals.original_sidemove <= -5.0f)
			cmd->sidemove = -cl_sidespeed->GetFloat();
	}*/

	auto commands_to_add = 0;

	do
	{
		auto sequence_number = commands_to_add + cmd->command_number;

		auto command = g_Input->GetUserCmd(sequence_number);
		auto verified_command = g_Input->GetVerifiedCmd(sequence_number);

		memcpy(command, cmd, sizeof(CUserCmd)); //-V598

		if (command->tick_count != INT_MAX && g_ClientState->m_nDeltaTick > 0)
			g_Prediction->Update(g_ClientState->m_nDeltaTick, true, g_ClientState->m_nLastCommandAck, g_ClientState->m_nLastOutgoingCommand + g_ClientState->m_nChokedCommands);

		command->command_number = sequence_number;
		command->hasbeenpredicted = command->tick_count != INT_MAX;

		++g_ClientState->m_nChokedCommands; //-V807

		if (g_ClientState->m_NetChannel)
		{
			++g_ClientState->m_NetChannel->m_nChokedPackets;
			++g_ClientState->m_NetChannel->m_nOutSequenceNr;
		}

		Math::Normalize3(command->viewangles);

		memcpy(&verified_command->m_cmd, command, sizeof(CUserCmd)); //-V598
		verified_command->m_crc = command->GetChecksum();

		++commands_to_add;
	} while (commands_to_add != tickbase_shift);

	*(bool*)((uintptr_t)g_Prediction + 0x24) = true;
	*(int*)((uintptr_t)g_Prediction + 0x1C) = 0;
}

void CExploits::Doubletap(CUserCmd* m_pcmd)
{
	if (!g_LocalPlayer) return;
	if (!g_LocalPlayer->IsAlive() || g_LocalPlayer->IsDormant()) return;

	auto pWeapon = g_LocalPlayer->m_hActiveWeapon();
	if (!pWeapon) return;


	g_Options.Doubletap = true;
	//g_CVar->ConsolePrintf("test\n");
	static auto recharge_double_tap = false;
	static auto last_double_tap = 0;

	if (recharge_double_tap)
	{
		recharge_double_tap = false;
		recharging_double_tap = true;
		g_TicksAllowed = 0;
		g_NextTickbaseShift = 0;
		return;
	}
	g_CVar->ConsolePrintf("test 0\n");
	if (recharging_double_tap)
	{
		auto recharge_time = pWeapon->CanDoubletap() ? TIME_TO_TICKS(0.75f) : TIME_TO_TICKS(1.5f);

		if (fabs(g_FixedTickbase - last_double_tap) > recharge_time)
		{
			last_double_tap = 0;

			recharging_double_tap = false;
			g_Options.DoubletapKey = true;
		}
		else if (m_pcmd->buttons & IN_ATTACK)
			last_double_tap = g_FixedTickbase;
	}

	if (!g_Options.MDoubletap)
	{
		g_Options.Doubletap = false;
		g_Options.DoubletapKey = false;
		g_TicksAllowed = 0;
		g_NextTickbaseShift = 0;
		return;
	}
	g_CVar->ConsolePrintf("test 1\n");
	if (g_Options.DoubletapKey && g_Options.MDoubletapKey != g_Options.MHideShotsKey)
		g_Options.HideShotsKey = false;


	//if (antiaim::get().freeze_check)
	//	return true;

	auto max_tickbase_shift = pWeapon->GetMaxTickbaseShift();

     if (pWeapon->CanDoubletap())//-V648
	{
		auto next_command_number = m_pcmd->command_number + 1;
		auto user_cmd = g_Input->GetUserCmd(next_command_number);

		memcpy(user_cmd, m_pcmd, sizeof(CUserCmd)); //-V598
		user_cmd->command_number = next_command_number;

		copy_command(user_cmd, max_tickbase_shift);

		if (g_AimbotTargetIndex > 0)
		{
			g_DoubletapAim = true;
			g_DoubletapAimCheck = true;
		}

		recharge_double_tap = true;
		g_Options.Doubletap = false;
		g_Options.DoubletapKey = false;

		last_double_tap = g_FixedTickbase;
	}
	 else if (!pWeapon->CanDoubletap())
		g_TickbaseShift = max_tickbase_shift;


}